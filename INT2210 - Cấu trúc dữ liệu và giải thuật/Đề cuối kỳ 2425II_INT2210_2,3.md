# Đề thi cuối kỳ - Cấu trúc dữ liệu và giải thuật (2425II_INT2210_2,3)
 - Thời gian làm bài: **90 phút**
 - 4 câu, tổng 15 điểm. Nếu thí sinh làm đúng trên 10 điểm thì sẽ làm tròn xuống 10 điểm.

## Câu A
Thuật toán $\tt{MERGESORT}$ có cấu trúc như sau:

```
MERGESORT(ARRAY A):
    ARRAY R = {}
    IF LENGTH OF A IS AT MOST 1:
        RETURN A
    B = MERGESORT(FIRST HALF OF A)
    C = MERGESORT(SECOND HALF OF A)
    MERGE B AND C INTO R SO THAT R IS SORTED
    RETURN R
```

**1. (1đ)** Dòng mã giả trộn hai mảng đã sắp xếp $\tt{B}$, $\tt{C}$ vào mảng kết quả $\tt{R}$ đã không được trình bày chi tiết. Hãy viết mã giả chi tiết cho dòng này.

**2. (1đ)** Đánh giá độ phức tạp của phần cài đặt của bạn.

**3. (1đ)** Đánh giá độ phức tạp của cả thuật toán $\tt{MERGESORT}$.

**4. (1đ)** Nếu $\tt{B}$ là mảng sau sắp xếp của phần $\frac{1}{3}$ đầu của $\tt{A}$ và $\tt{C}$ là mảng sau sắp xếp của $\frac{2}{3}$ sau của $\tt{A}$ thì độ phức tạp của thuật toán có thay đổi không?

## Câu B
Chương trình tìm kiếm trên đồ thị $\tt{G}$, bắt đầu từ đỉnh $\tt{S}$ và mong muốn tìm đỉnh có giá trị $\tt{X}$ có cấu trúc như sau:

```
SEARCH(GRAPH G, VERTEX S, DESTINATION X):
    DATASTRUCTURE D
    PUSH S INTO D
    WHILE D IS NOT EMPTY:
        V = POP(D)
        IF V IS X:
            RETURN V
        PUSH CHILDREN OF V INTO D
    RETURN FALSE
```

**1. (1đ)** Nếu $\tt{G}$ là một cây (đồ thị không có chu trình) thì thuật toán của chúng ta là dạng tìm kiếm gì nếu cấu trúc dữ liệu của $\tt{D}$ là: **(a)** $\tt{STACK}$, **(b)** $\tt{QUEUE}$? Tại sao?

**2. (1đ)** Trong hai phương án về cấu trúc dữ liệu cho $\tt{D}$ thì có phương án nào có lợi thế hơn về thời gian phải chạy trước khi tìm được $\tt{X}$ không? Tại sao? Phân tích thêm về độ phức tạp không gian!

**3. (1đ)** Nếu $\tt{G}$ là một đồ thị tổng quát và có thể có chu trình thì thuật toán trên còn đúng không? Tại sao? Nếu không đúng phải sửa thế nào? Viết mã giả tương ứng!

**4. (1đ)** Phân tích độ phức tạp thời gian và không gian trong phần trên khi ta làm việc với đồ thị tổng quát.

## Câu C
Heapqueue là cấu trúc dữ liệu lưu các số trên các đỉnh một cây nhị phân sao cho giá trị tại mỗi đỉnh sẽ nhỏ hơn giá trị của bất kì người con nào của đỉnh đó.

**1. (1đ)** Chứng minh rằng với điều kiện trên thì giá trị tại gốc của cây cũng là giá trị nhỏ nhất trên toàn cây.

**2. (1đ)** Giả sử chúng ta đã có phần cài đặt của heapqueue sao cho ta có thể $\tt{push}$ một số vào queue và $\tt{pop}$ ra số nhỏ nhất tại thời điểm đó. Hãy viết mã giả cho một thuật toán sắp xếp gọi các tính năng này.

**3. (1đ)** Khi ta thay đổi giá trị tại gốc của một heapqueue thì cây mới nhận được có thể không còn là heapqueue nữa (giá trị tại gốc có thể không nhỏ hơn hai người con của nó). Giả sử chúng ta được cung cấp sẵn thuật toán $\tt{heapify}$ với tính năng sửa cây này thành một heapqueue.

Bây giờ, trong một diễn biến khác chúng ta lại gán tuỳ ý các số vào các đỉnh một cây nhị phân. Hãy gọi thuật toán $\tt{heapify}$ một cách hợp lí để biến cây này thành một heapqueue. Viết giả mã cho chúng.

**4. (1đ)** Biết rằng độ phức tạp của thuật toán $\tt{heapify}$ là $O(\log n)$ với $n$ là số nút trong cây cần sửa thì độ phức tạp tổng thể của mã giả chúng ta viết trên là gì?

## Câu Z
Cho một sân gạch kích thước $2 \times n$. Hãy viết chương trình tính số cách lát đầy sân gạch trên dùng các viên gạch có kích thước: $1 \times 1$, $1 \times 2$ và $2 \times 1$. (Lưu ý viên gạch $2 \times 1$ là viên gạch $1 \times 2$ sau khi xoay 90 độ.)

**1. (1đ)** Hãy viết thuật toán tính số này bằng chiến lược vét cạn. Cho phép thời gian tính toán là mũ (theo $n$).

**2. (1đ)** Hãy viết thuật toán tính số này bằng chiến lược quy hoạch động. Thời gian phải là đa thức (theo $n$).

**3. (1đ)** Có chiến lược nào triển khai công thức của quy hoạch động nhưng lại dùng thời gian là $O(\log n)$ được hay không? (Gợi ý: dùng ma trận.)
